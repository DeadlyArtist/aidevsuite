{
    "securityId": "aidevsuite_a1b2c3",
    "name": "Chat",
    "code": "await requireApiKey();\nlet initialized = false;\n\nconst inputs = [];\nconst variables = [];\n\nconst variableDivider = createAnchor();\nawait show(variableDivider); // Show divider for insert reference.\nconst inputDivider = createAnchor();\nawait show(inputDivider); // Show divider for insert reference.\n\nconst promptInput = createInput(textInputType, {\n    placeholder: \"Enter your prompt here...\",\n    onValidate: storeSession,\n});\nawait show(promptInput, { noAccept: true });\n\nconst context = [];\nconst contextElements = [];\n\nasync function removeInput(id) {\n    const index = inputs.findIndex(i => i.element.id == id);\n    const input = inputs[index];\n    inputs.splice(index, 1);\n    await remove(input.container.id);\n    await storeSession();\n}\n\nasync function removeVariable(id) {\n    const index = variables.findIndex(i => i.nameInput.id == id);\n    const variable = variables[index];\n    variables.splice(index, 1);\n    await remove(variable.container.id);\n    await storeSession();\n}\n\nasync function addInput(role, options) {\n    options ??= {};\n\n    let element;\n    if (options.url == null) {\n        element = createInput(textInputType, {\n            placeholder: `Enter ${role} message...`,\n            defaultValue: options.text,\n            onValidate: storeSession,\n        });\n    } else {\n        element = createInput(imageInputType, {\n            placeholder: `Enter url...`,\n            defaultValue: options.url,\n            onValidate: storeSession,\n        });\n    }\n\n    const container = createGroup([\n        element,\n    ], {\n        rightElements: [createSimpleButton(createPresetIcon(\"close\"), () => removeInput(element.id), { title: \"Delete\" })]\n    });\n\n    inputs.push({ role, element, container });\n    await show(container, { insertAfter: inputDivider.id, noAccept: true });\n}\n\nasync function _getNextValidNumber() {\n    const allInputs = await readAll();\n    let takenNumbers = new Set();\n    for (const variable of variables) {\n        const nameInput = variable.nameInput;\n        const name = allInputs[nameInput.id].text;\n\n        let parts = name.split('$var');\n        if (parts.length === 2) {\n            let number = parseInt(parts[1].substring(0, parts[1].length - 1));\n            if (!isNaN(number)) {\n                takenNumbers.add(number);\n            }\n        }\n    }\n    let nextValidNumber = 1;\n    while (takenNumbers.has(nextValidNumber)) {\n        nextValidNumber++;\n    }\n\n    return nextValidNumber;\n}\n\nasync function addVariable(options) {\n    options ??= {};\n\n    let lastValue = options.name ?? ('$' + 'var' + await _getNextValidNumber() + '$');\n    const nameInput = createInput(textInputType, {\n        placeholder: \"Enter variable name...\",\n        defaultValue: lastValue,\n        onValidate: async (element) => {\n            let text = element.text;\n            text = text.trim();\n\n            if (!text || lastValue == text) return;\n            if (text == '$') {\n                if (lastValue.length == 0) {\n                    text = '$' + 'var' + await _getNextValidNumber() + '$';\n                } else {\n                    text = '';\n                }\n            } else {\n                if (!text.startsWith('$')) text = '$' + text;\n                if (!text.endsWith('$')) text += '$';\n            }\n\n            lastValue = text;\n            await update(element.id, { text, retainSelection: true });\n            await storeSession();\n        }\n    });\n    const valueInput = createInput(textInputType, {\n        placeholder: \"Enter variable value...\",\n        defaultValue: options.value,\n        onValidate: storeSession,\n    });\n    const container = createGroup([\n        nameInput,\n        valueInput,\n    ], {\n        rightElements: [createSimpleButton(createPresetIcon(\"close\"), () => removeVariable(nameInput.id), { title: \"Delete\" })]\n    });\n\n    variables.push({ container, nameInput, valueInput });\n    await show(container, { insertAfter: variableDivider.id, noAccept: true });\n}\n\nasync function removeMessage(id) {\n    const index = contextElements.findIndex(e => e.id == id);\n    context.splice(index, 1);\n    contextElements.splice(index, 1);\n    await remove(id);\n    await storeSession();\n}\n\nfunction createMessageElement(message) {\n    let messageElement;\n    if (message.role == userRole || message.url) {\n        if (message.url) {\n            messageElement = createImage(message.url);\n        } else {\n            messageElement = createGroup(createText(paragraphType, `User:\\n${message.prompt}`, { bordered: true }));\n        }\n    } else if (message.role == assistantRole) {\n        messageElement = createMarkdown(message.prompt);\n    } else if (message.role == systemRole) {\n        messageElement = createGroup(createText(paragraphType, `System:\\n${message.prompt}`, { bordered: true }));\n    }\n\n    messageElement.options ??= {};\n    messageElement.options.rightElements = [createSimpleButton(createPresetIcon(\"close\"), () => removeMessage(messageElement.id), { title: \"Delete\" })];\n\n    return messageElement;\n}\n\nasync function run() {\n    const allInputs = await readAll();\n\n    const variableValues = [];\n    // Handle variables\n    for (const variable of variables) {\n        const nameInput = variable.nameInput;\n        const valueInput = variable.valueInput;\n\n        const name = allInputs[nameInput.id].text;\n        const value = allInputs[valueInput.id].text;\n\n        variableValues.push({ name, value });\n    }\n\n    // Replace variables in inputs\n    for (const input of inputs) {\n        let prompt = input.element.type == imageInputType ? allInputs[input.element.id].url : allInputs[input.element.id].text;\n        for (const variable of variableValues) {\n            prompt = prompt.replaceAll(variable.name, variable.value);\n        }\n        let message;\n        if (input.element.type == imageInputType) {\n            context.push(message = toImageMessage(prompt));\n        } else {\n            context.push(message = toMessage(input.role, prompt));\n        }\n\n        const messageElement = createMessageElement(message);\n        contextElements.push(messageElement);\n        await show(messageElement, { insertBefore: navbar.id });\n    }\n\n    // Handle the main user prompt\n    let prompt = allInputs[promptInput.id].text;\n    for (const variable of variableValues) {\n        prompt = prompt.replaceAll(variable.name, variable.value);\n    }\n    const promptMessage = toUserMessage(prompt);\n    context.push(promptMessage);\n    const promptMessageElement = createMessageElement(promptMessage);\n    contextElements.push(promptMessageElement);\n    await show(promptMessageElement, { insertBefore: navbar.id });\n\n    // Show assistant message stream target\n    const assistantMessageElement = createMessageElement({ role: assistantRole });\n    assistantMessageElement.options ??= {};\n    assistantMessageElement.options.placeholder = \"Streaming...\";\n    contextElements.push(assistantMessageElement);\n    await show(assistantMessageElement, { insertBefore: navbar.id });\n\n    const result = await chat(context, { id: assistantMessageElement.id, model: allInputs[modelSelect.id].value });\n    context.push(toAssistantMessage(result));\n\n    await storeSession();\n}\n\nasync function exportContext(asObject = false) {\n    if (asObject) {\n        return context;\n    }\n\n    const content = JSON.stringify(context, null, 2);\n    if (download) await requestFileDownload(\"context.json\", commonMimeTypes.json, content);\n    return content;\n}\n\nasync function importContext(newContext = null) {\n    const importInput = createInput(fileInputType, {\n        allowedExtensions: [\".json\"],\n        selectDescription: \"Select context JSON file\",\n    });\n\n    if (newContext == null) {\n        try {\n            const result = await show(createGroup([\n                createTitle(\"Import Context\"),\n                importInput\n            ]), { location: dialogLocation });\n            file = result.files[0];\n        } catch (error) {\n            await setStatus(\"Import canceled.\");\n            return;\n        }\n\n        const fileContent = file.text;\n\n        try {\n            newContext = JSON.parse(fileContent) ?? [];\n        } catch (error) {\n            await setStatus(\"Failed to parse the JSON file. provide a valid context JSON file.\");\n            return;\n        }\n    }\n\n\n    context.length = 0;\n    contextElements.forEach(e => remove(e.id));\n    contextElements.length = 0;\n    for (const message of newContext) {\n        context.push(message);\n        const messageElement = createMessageElement(message);\n        contextElements.push(messageElement);\n\n        await show(messageElement, { insertBefore: navbar.id });\n    }\n\n    if (newContext == null) await setStatus(\"Context imported successfully.\");\n    await storeSession();\n}\n\nasync function exportSetup(asObject = false) {\n    const allInputs = await readAll();\n\n    const variableValues = [];\n    // Handle variables\n    for (const variable of variables) {\n        const nameInput = variable.nameInput;\n        const valueInput = variable.valueInput;\n\n        const name = allInputs[nameInput.id].text;\n        const value = allInputs[valueInput.id].text;\n\n        variableValues.push({ name, value });\n    }\n\n    // Handle inputs\n    const prompts = [];\n    for (const input of inputs) {\n        let message = {\n            role: input.role,\n        }\n\n        if (input.element.type == imageInputType) {\n            message.url = allInputs[input.element.id].url;\n        } else {\n            message.text = allInputs[input.element.id].text;\n        }\n\n        prompts.push(message);\n    }\n\n    const prompt = allInputs[promptInput.id].text;\n    const model = allInputs[modelSelect.id].value;\n    const context = { variables: variableValues, prompts, prompt, model };\n    if (asObject) {\n        return context;\n    }\n\n    const content = JSON.stringify(context, null, 2);\n    await requestFileDownload(\"setup.json\", commonMimeTypes.json, content);\n\n    return content;\n}\n\nasync function importSetup(newSetup = null) {\n    const importInput = createInput(fileInputType, {\n        allowedExtensions: [\".json\"],\n        selectDescription: \"Select setup JSON file\",\n    });\n\n    if (newSetup == null) {\n        try {\n            const result = await show(createGroup([\n                createTitle(\"Import Setup\"),\n                importInput\n            ]), { location: dialogLocation });\n            file = result.files[0];\n        } catch (error) {\n            await setStatus(\"Import canceled.\");\n            return;\n        }\n\n        const fileContent = file.text;\n\n        try {\n            newSetup = JSON.parse(fileContent);\n        } catch (error) {\n            await setStatus(\"Failed to parse the JSON file. provide a valid setup JSON file.\");\n            return;\n        }\n\n        await storeSession();\n    }\n\n\n    for (const variable of variables) {\n        await remove(variable.container.id);\n    }\n    variables.length = 0;\n\n    for (const input of inputs) {\n        await remove(input.container.id);\n    }\n    inputs.length = 0;\n\n    for (const variable of newSetup.variables ?? []) {\n        await addVariable(variable);\n    }\n\n    for (const input of newSetup.prompts ?? []) {\n        await addInput(input.role, input);\n    }\n\n    await update(promptInput.id, { text: newSetup.prompt ?? \"\" });\n    await update(modelSelect.id, { value: newSetup.model ?? models[0] });\n\n    if (newSetup == null) await setStatus(\"Setup imported successfully.\");\n}\n\nasync function exportSession(asObject = false) {\n    const context = await exportContext(true);\n    const setup = await exportSetup(true);\n    const session = { context, setup };\n    if (asObject) {\n        return session;\n    }\n\n    const content = JSON.stringify(session);\n    await requestFileDownload(\"session.json\", commonMimeTypes.json, content);\n}\n\nasync function importSession(newSession = null) {\n    const importInput = createInput(fileInputType, {\n        allowedExtensions: [\".json\"],\n        selectDescription: \"Select setup JSON file\",\n    });\n\n    if (newSession == null) {\n        try {\n            const result = await show(createGroup([\n                createTitle(\"Import Session\"),\n                importInput\n            ]), { location: dialogLocation });\n            file = result.files[0];\n        } catch (error) {\n            await setStatus(\"Import canceled.\");\n            return;\n        }\n\n        const fileContent = file.text;\n\n        try {\n            newSession = JSON.parse(fileContent);\n        } catch (error) {\n            await setStatus(\"Failed to parse the JSON file. provide a valid session JSON file.\");\n            return;\n        }\n    }\n\n    importContext(newSession.context ?? []);\n    importSetup(newSession.setup ?? []);\n\n    if (newSession == null) await setStatus(\"Session imported successfully.\");\n}\n\nasync function storeSession() {\n    if (!initialized || !hasStore) return;\n\n    const session = await exportSession(true);\n    try {\n        Store.set('session', session);\n    } catch (e) { }\n}\n\nasync function clearSession() {\n    await importSession({});\n}\n\nconst exportContextButton = createButton(createText(paragraphType, \"Export Context\"), exportContext);\nconst exportSetupButton = createButton(createText(paragraphType, \"Export Setup\"), exportSetup);\nconst exportSessionButton = createButton(createText(paragraphType, \"Export Session\"), exportSession);\nconst exportButtonBar = createHorizontalList([exportContextButton, exportSetupButton, exportSessionButton], { gap: 2, centered: true });\n\nconst importContextButton = createButton(createText(paragraphType, \"Import Context\"), importContext);\nconst importSetupButton = createButton(createText(paragraphType, \"Import Setup\"), importSetup);\nconst importSessionButton = createButton(createText(paragraphType, \"Import Session\"), importSession);\nconst importButtonBar = createHorizontalList([importContextButton, importSetupButton, importSessionButton], { gap: 2, centered: true });\n\nconst topButtons = createGroup([exportButtonBar, importButtonBar]);\nawait show(topButtons, { insertAt: 0 });\n\nconst addImageInputButton = createButton(createText(paragraphType, \"Add Image\"), () => addInput(userRole, { url: \"\" }));\nconst addUserInputButton = createButton(createText(paragraphType, \"Add User\"), () => addInput(userRole));\nconst addSystemInputButton = createButton(createText(paragraphType, \"Add System\"), () => addInput(systemRole));\nconst addAssistantInputButton = createButton(createText(paragraphType, \"Add Assistant\"), () => addInput(assistantRole));\nconst addVariableButton = createButton(createText(paragraphType, \"Add Variable\"), () => addVariable());\n\nconst navbar = createHorizontalList(\n    [addImageInputButton, addUserInputButton, addSystemInputButton, addAssistantInputButton, addVariableButton],\n    { gap: 2, centered: true }\n);\n\nawait show(navbar, { insertAfter: topButtons.id });\n\nconst models = await ChatHelpers.getAvailableModels();\nif (models.length == 0) {\n    throw new Error('No models available.');\n}\nconst modelSelect = createInput(selectInputType, {\n    choices: models.map(identifier => ({\n        name: ChatHelpers.chatModelNames[identifier],\n        value: identifier\n    })),\n    onValidate: storeSession,\n});\nconst clearButton = createButton(createText(paragraphType, \"Clear\"), clearSession, { title: \"Clear Entire Session\" });\nconst chatButton = createButton(createText(paragraphType, \"Chat\"), run);\nawait show(createNavBar([createHorizontalList([modelSelect, clearButton]), chatButton]), { noAccept: true });\n\ninitialized = true;\nconst hasStore = await Store.exists();\nif (hasStore) {\n    const session = await Store.get('session');\n    if (session != null) await importSession(session);\n}\n\nawait setStatus(\"Ready to chat\"); // Set status as flavor\nawait forever();\n",
    "link": "chat"
}